import { defineRule } from "../define-rule";
import path from "node:path";

const MARKER_START = "# @generated by pullup - do not edit manually";
const MARKER_END = "# @end-generated";

interface CodeownersEntry {
  pattern: string;
  owners: string[];
}

export const codeownersRule = defineRule(() => ({
  from: ["**/CODEOWNERS"],
  output: ".github/CODEOWNERS",
  transform: (sources, { root, existingContents }) => {
    const entries = sources.flatMap((file) => {
      const parsed = parse(file.contents);
      return resolveEntries(parsed, file.path, root);
    });

    if (entries.length === 0) {
      return existingContents ?? "";
    }

    return updateMarkerSection(existingContents ?? "", entries);
  },
}));

function resolveEntries(
  entries: CodeownersEntry[],
  filePath: string,
  root: string,
): CodeownersEntry[] {
  const relativeDir = path.relative(root, path.dirname(filePath));

  return entries.map((entry) => {
    if (entry.pattern === "*") {
      return {
        pattern: `/${relativeDir}/`,
        owners: entry.owners,
      };
    }

    const normalizedPattern = entry.pattern.startsWith("/")
      ? entry.pattern.slice(1)
      : entry.pattern;

    const resolvedPattern = relativeDir
      ? `/${path.join(relativeDir, normalizedPattern)}`
      : `/${normalizedPattern}`;

    return {
      pattern: resolvedPattern,
      owners: entry.owners,
    };
  });
}

function parse(content: string): CodeownersEntry[] {
  const entries = content
    .split("\n")
    .map((line) => line.trim())
    .filter((line) => line !== "" && !line.startsWith("#"))
    .map((line) => {
      const [pattern = "", ...owners] = line.split(/\s+/);
      return { pattern, owners };
    });

  return entries;
}

function stringify(entries: CodeownersEntry[]): string {
  return entries.map((e) => `${e.pattern} ${e.owners.join(" ")}`).join("\n");
}

function updateMarkerSection(
  existing: string,
  entries: CodeownersEntry[],
): string {
  const generated = `${MARKER_START}\n\n${stringify(entries)}\n\n${MARKER_END}`;

  const startIdx = existing.indexOf(MARKER_START);
  const endIdx = existing.indexOf(MARKER_END);

  if (startIdx === -1 || endIdx === -1) {
    const trimmed = existing.trimEnd();
    return trimmed ? `${trimmed}\n\n${generated}\n` : `${generated}\n`;
  }

  const before = existing.slice(0, startIdx);
  const after = existing.slice(endIdx + MARKER_END.length);

  return `${before}${generated}${after}`;
}
